1. SQL 중심 개발의 문제
 - 반복되는 코드 (CRUD)
 - RDB(관계형DB)와 객체지향 개발과 맞지 않는 부분이 많음 : 조회, 입력 등... 복잡해짐
   객체 답게 모델링할 수록 SQL 매핑 작업이 늘어남

2. JPA
 - ORM 기술 표준 (Object-relational mapping_객체 관계 매핑)
 - JDBC와 애플리케이션(JAVA) 사이에서 동작
 - 패러다임의 불일치를 해결

3. 영속성 컨텍스트

4. 스키마 자동생성 옵션 (운영서버에서는 CREATE, CREATE-DROP, UPDATE는 절대 사용하면 안됨)
   - CREATE : DROP 후 CREATE
   - CREATE : DROP : CREATE 후 종료 시 DROP
   - UPDATE : 기존 테이블을 DROP 하지 않고 ALTER, 컬럼 추가만 가능
   - VALIDATE : 엔티티와 테이블이 정상 매핑되었는지 확인
   - NONE : 기능을 사용하지 않음

5. 기본키 매핑
   - 어노테이션 > id(직접 할당), GeneratedValue(자동 생성)
   - IDDENTIFY 타입은 persist를 호출 하는 시점에 insert 쿼리가 날아감
   - SEQUENSE의 ALLOCATIONSIZE 옵션 사용 시 필요할 때마다 DB에 시퀀스 값 호출 (해당 값을 50으로 설정 시 50개 차면 그때 호출됨)

6.
조인 전략 (정석) : 테이터 정규화, 저장공간 효율 높음, 조회 시 조인을 많이 사용 (성능 저하), 조회 쿼리 복잡, 데이터 저장 시 insert 쿼리를 2번 호출
단일테이블 전략 : 조인이 필요 없음, 조회 쿼리가 단순, 자식 엔티티가 매핑한 컬럼은 모두 null, 각 테이블이 커질 수 있어 오히려 성능이 느려질 수 있음 (일반적으로는 더 빠름)
구현 클래스마다 테이블 전략 (쓰면 안되는 전략...) :  서브타입을 명확하게 구분하여 처리할 때 효과적, not null 제약 조건 사용 가능, 여러 테이블 조회 시 성능 느림 (union all)

7. mappedsuperclass 는 테이블과 매핑되지 않음