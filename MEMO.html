1. SQL 중심 개발의 문제
 - 반복되는 코드 (CRUD)
 - RDB(관계형DB)와 객체지향 개발과 맞지 않는 부분이 많음 : 조회, 입력 등... 복잡해짐
   객체 답게 모델링할 수록 SQL 매핑 작업이 늘어남

2. JPA
 - ORM 기술 표준 (Object-relational mapping_객체 관계 매핑)
 - JDBC와 애플리케이션(JAVA) 사이에서 동작
 - 패러다임의 불일치를 해결

3. 영속성 컨텍스트

4. 스키마 자동생성 옵션 (운영서버에서는 CREATE, CREATE-DROP, UPDATE는 절대 사용하면 안됨)
   - CREATE : DROP 후 CREATE
   - CREATE : DROP : CREATE 후 종료 시 DROP
   - UPDATE : 기존 테이블을 DROP 하지 않고 ALTER, 컬럼 추가만 가능
   - VALIDATE : 엔티티와 테이블이 정상 매핑되었는지 확인
   - NONE : 기능을 사용하지 않음

5. 기본키 매핑
   - 어노테이션 > id(직접 할당), GeneratedValue(자동 생성)
   - IDDENTIFY 타입은 persist를 호출 하는 시점에 insert 쿼리가 날아감
   - SEQUENSE의 ALLOCATIONSIZE 옵션 사용 시 필요할 때마다 DB에 시퀀스 값 호출 (해당 값을 50으로 설정 시 50개 차면 그때 호출됨)

6.
조인 전략 (정석) : 테이터 정규화, 저장공간 효율 높음, 조회 시 조인을 많이 사용 (성능 저하), 조회 쿼리 복잡, 데이터 저장 시 insert 쿼리를 2번 호출
단일테이블 전략 : 조인이 필요 없음, 조회 쿼리가 단순, 자식 엔티티가 매핑한 컬럼은 모두 null, 각 테이블이 커질 수 있어 오히려 성능이 느려질 수 있음 (일반적으로는 더 빠름)
구현 클래스마다 테이블 전략 (쓰면 안되는 전략...) :  서브타입을 명확하게 구분하여 처리할 때 효과적, not null 제약 조건 사용 가능, 여러 테이블 조회 시 성능 느림 (union all)

7. mappedsuperclass 는 테이블과 매핑되지 않음

8. 프록시
 - 실제 클래스를 상속 받아서 만들어짐
 - 실제 클래스와 모양이 같음
 - 프록시 객체는 실제 객체의 참조(Target)를 보관함
 - 프록시 객체는 처음 사용할 때 한번만 초기화됨
 - 프록시 객체가 초기화 될 때 실제 엔티티로 바뀌는 것이 아님
 - 타입 체크 시 (== 비교 실패함, instance of 사용하여 비교해야 함)

9. 즉시로딩 지연로딩
 - 가급적 지연로딩만 사용
 - 걸려있는게 많을 수록 조인이 많아짐 > 성능 저하
 - 기본이 즉시로딩(EAGER)이기 때문에 지연로딩(LAZY)으로 지정해줘야함

10. 영속성 전이 (CASCADE)
 - 영속성 전이와 연관관계 매핑하는 것과는 관계가 없음
 - ALL : 모두 적용 , PERSIST : 영속, REMOVE : 삭제
 - 하나의 부모로부터만 소유될 때 사용하면 좋음 / 다른 엔티티와 관계가 있으면 쓰면 안됨
 - 부모와 자식의 라이프 사이클이 동일할 때 사용해야함

11.